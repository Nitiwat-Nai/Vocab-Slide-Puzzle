<!DOCTYPE html>
<html lang="th">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Vocab Slide Puzzle</title>
    <!-- FontAwesome Icons -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <!-- Google Fonts -->
    <link href="https://fonts.googleapis.com/css2?family=Fredoka:wght@400;600&family=Kanit:wght@300;500&display=swap" rel="stylesheet">
    
    <style>
        :root {
            --primary: #6c5ce7;
            --bg-grad: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            --board-current-width: 90vw; 
            --board-max-width: 400px;
            --tile-count: 3; 
            --gap: 4px;
        }

        body {
            margin: 0;
            padding: 0;
            background: var(--bg-grad);
            font-family: 'Fredoka', 'Kanit', sans-serif;
            height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            overflow: hidden;
            color: white;
            user-select: none;
            -webkit-tap-highlight-color: transparent;
        }

        /* --- 1. Title & Secret Mode Animation --- */
        .app-title {
            font-size: 2rem;
            margin-top: 20px;
            margin-bottom: 10px;
            text-shadow: 0 4px 6px rgba(0,0,0,0.2);
            z-index: 10;
            cursor: pointer;
            transition: transform 0.3s;
        }

        /* เอฟเฟคหัวใจเต้น เมื่อเปิดโหมดลับ */
        .app-title.active-bot {
            animation: heartbeat 1.5s infinite ease-in-out;
        }

        @keyframes heartbeat {
            0% { transform: scale(1); }
            15% { transform: scale(1.1); }
            30% { transform: scale(1); }
            45% { transform: scale(1.1); }
            60% { transform: scale(1); }
            100% { transform: scale(1); }
        }

        /* --- Screen Logic --- */
        .screen {
            display: none;
            flex-direction: column;
            align-items: center;
            width: 100%;
            height: 100%;
            animation: fadeIn 0.5s ease;
        }
        .screen.active { display: flex; }
        @keyframes fadeIn { from { opacity: 0; transform: translateY(10px); } to { opacity: 1; transform: translateY(0); } }

        /* --- Menu --- */
        .menu-container {
            display: flex;
            flex-direction: column;
            gap: 20px;
            margin-top: 40px;
            width: 80%;
            max-width: 300px;
        }
        .menu-btn {
            background: rgba(255, 255, 255, 0.2);
            border: 2px solid rgba(255,255,255,0.4);
            padding: 20px;
            border-radius: 15px;
            color: white;
            font-size: 1.2rem;
            cursor: pointer;
            backdrop-filter: blur(5px);
            transition: all 0.2s;
            display: flex;
            align-items: center;
            justify-content: space-between;
        }
        .menu-btn:hover { background: rgba(255, 255, 255, 0.3); transform: scale(1.02); }

        /* --- Game Board --- */
        .top-bar { width: min(90vw, 400px); display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px; }
        .stats-bar { width: min(90vw, 400px); background: rgba(0,0,0,0.2); padding: 8px 15px; border-radius: 50px; display: flex; justify-content: space-between; margin-bottom: 15px; font-size: 0.9rem; box-sizing: border-box; }
        .preview-box { width: 50px; height: 50px; background: rgba(255, 255, 255, 0.9); border-radius: 10px; display: flex; align-items: center; justify-content: center; color: var(--primary); font-size: 24px; border: 2px solid rgba(255,255,255,0.5); transition: color 0.3s; }
        
        .game-board {
            width: var(--board-current-width);
            height: var(--board-current-width);
            max-width: var(--board-max-width);
            max-height: var(--board-max-width);
            background: rgba(255, 255, 255, 0.15);
            border-radius: 15px;
            padding: 5px;
            display: grid;
            grid-template-columns: repeat(var(--tile-count), 1fr);
            grid-template-rows: repeat(var(--tile-count), 1fr);
            gap: var(--gap);
            box-shadow: 0 8px 32px 0 rgba(31, 38, 135, 0.37);
            backdrop-filter: blur(4px);
            border: 1px solid rgba(255, 255, 255, 0.18);
            position: relative;
            margin: 0 auto;
        }

        .tile {
            background: white;
            border-radius: 6px;
            cursor: pointer;
            position: relative;
            overflow: hidden;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: transform 0.1s;
        }
        .tile.empty { background: transparent; cursor: default; border: 2px dashed rgba(255,255,255,0.2); }
        
        .tile-content {
            position: absolute;
            font-size: calc(min(90vw, 400px) * 0.75);
            color: var(--primary);
            width: min(90vw, 400px);
            height: min(90vw, 400px);
            display: flex;
            align-items: center;
            justify-content: center;
            pointer-events: none;
            line-height: 1;
            transition: color 0.3s;
        }

        /* --- Large Controls (1.5x) --- */
        .controls { margin-top: 20px; display: flex; gap: 20px; }
        .btn-ctrl {
            border: none;
            width: 68px; /* 1.5x size */
            height: 68px;
            border-radius: 50%;
            display: flex; align-items: center; justify-content: center;
            font-size: 1.65rem;
            cursor: pointer;
            box-shadow: 0 6px 10px rgba(0,0,0,0.3);
            transition: transform 0.1s;
        }
        .btn-ctrl:active { transform: scale(0.9); }
        .btn-reset { background: #fdcb6e; color: #d63031; }
        .btn-solve { background: #74b9ff; color: #0984e3; }
        .btn-home { background: #fab1a0; color: #fff; }

        /* --- Result Overlay --- */
        .overlay {
            position: fixed; top: 0; left: 0; right: 0; bottom: 0;
            background: rgba(0,0,0,0.85);
            display: flex; flex-direction: column;
            align-items: center; justify-content: center;
            z-index: 100; opacity: 0; pointer-events: none;
            transition: opacity 0.3s;
        }
        .overlay.show { opacity: 1; pointer-events: all; }
        
        .result-card {
            background: white; color: #333; padding: 30px;
            border-radius: 20px; text-align: center; width: 75%; max-width: 320px;
            animation: popIn 0.4s cubic-bezier(0.175, 0.885, 0.32, 1.275);
        }
        .result-stats { background: #f1f2f6; border-radius: 10px; padding: 10px; margin: 15px 0; font-size: 0.9rem; color: #636e72; }
        
        .btn {
            background: var(--primary); color: white; border: none;
            padding: 12px 25px; border-radius: 50px; font-size: 1rem;
            cursor: pointer; margin-top: 10px; width: 100%;
            font-family: 'Fredoka', sans-serif;
        }

        /* --- Bot Indicator (Optional: small text) --- */
        .bot-status {
            position: absolute; top: 10px; right: 10px;
            background: rgba(255,0,0,0.2); padding: 5px 10px;
            border-radius: 20px; font-size: 0.7rem; 
            display: none; animation: fadeIn 0.5s;
        }

        @keyframes popIn { from { transform: scale(0.5); opacity: 0; } to { transform: scale(1); opacity: 1; } }
    </style>
</head>
<body>

    <!-- 1. Title with Double Tap Handler -->
    <h1 class="app-title" id="appTitle"><i class="fa-solid fa-puzzle-piece"></i> Vocab Slide Puzzle</h1>
    <div id="botStatus" class="bot-status"><i class="fa-solid fa-robot"></i> AUTO</div>

    <!-- MENU SCREEN -->
    <div id="screen-menu" class="screen active">
        <div style="text-align: center; margin-top: 20px; opacity: 0.8;">Select Difficulty</div>
        <div class="menu-container">
            <button class="menu-btn" onclick="initGameSession(3)">
                <div>
                    <div style="font-weight: bold;">Easy (3x3)</div>
                    <small style="opacity: 0.8;">Standard Mode</small>
                </div>
                <i class="fa-solid fa-star"></i>
            </button>
            <button class="menu-btn" onclick="initGameSession(4)">
                <div>
                    <div style="font-weight: bold;">Hard (4x4)</div>
                    <small style="opacity: 0.8;">Challenge Mode</small>
                </div>
                <i class="fa-solid fa-fire"></i>
            </button>
        </div>
        <div style="text-align: center; margin-top: auto; margin-bottom: 20px; opacity: 0.5; font-size: 0.8rem;">
            Double tap title to toggle Secret Bot
        </div>
    </div>

    <!-- GAME SCREEN -->
    <div id="screen-game" class="screen">
        <div class="top-bar">
            <div>
                <span style="opacity: 0.7; font-size: 0.9rem;">Stage <span id="displayStage">1</span></span>
                <div style="font-weight: bold;" id="modeName">3x3 Mode</div>
            </div>
            <div class="preview-box">
                <i id="previewIcon" class="fa-solid fa-question"></i>
            </div>
        </div>

        <div class="stats-bar">
            <span><i class="fa-regular fa-clock"></i> <span id="timer">00:00</span></span>
            <span><i class="fa-solid fa-shoe-prints"></i> <span id="moveCount">0</span> Moves</span>
        </div>

        <div class="game-board" id="board">
            <!-- Tiles Generated Here -->
        </div>

        <div class="controls">
            <button class="btn-ctrl btn-home" onclick="goHome()" title="Home"><i class="fa-solid fa-house"></i></button>
            <button class="btn-ctrl btn-reset" onclick="resetLevel()" title="Reset"><i class="fa-solid fa-rotate-right"></i></button>
            <button class="btn-ctrl btn-solve" onclick="triggerSmartSolve()" title="Help"><i class="fa-solid fa-wand-magic-sparkles"></i></button>
        </div>
    </div>

    <!-- RESULT OVERLAY -->
    <div class="overlay" id="overlay">
        <div class="result-card">
            <i id="resultIcon" class="fa-solid fa-star" style="font-size: 60px; color: var(--primary);"></i>
            <h2 id="resultWord" style="margin: 10px 0; color: #2d3436;">WORD</h2>
            <div id="resultThai" style="font-size: 1.4rem; color: #636e72; font-family: 'Kanit';">คำแปล</div>
            <div class="result-stats">
                Time: <span id="resTime">00:00</span> | Moves: <span id="resMoves">0</span>
            </div>
            <button class="btn" style="background:#ffeaa7; color:#d63031;" onclick="speakWord()">
                <i class="fa-solid fa-volume-high"></i> Listen
            </button>
            <button class="btn" onclick="nextLevel()">Next Stage <i class="fa-solid fa-arrow-right"></i></button>
        </div>
    </div>

    <script>
        // --- 1. Word Database ---
        const fullDatabase = [
            { word: "Cat", thai: "แมว", icon: "fa-cat", color: "#e17055" },
            { word: "Dog", thai: "สุนัข", icon: "fa-dog", color: "#6c5ce7" },
            { word: "Fish", thai: "ปลา", icon: "fa-fish", color: "#0984e3" },
            { word: "Bird", thai: "นก", icon: "fa-dove", color: "#00b894" },
            { word: "Rocket", thai: "จรวด", icon: "fa-rocket", color: "#a29bfe" },
            { word: "Dragon", thai: "มังกร", icon: "fa-dragon", color: "#d63031" },
            { word: "Car", thai: "รถยนต์", icon: "fa-car", color: "#ff7675" },
            { word: "Bicycle", thai: "จักรยาน", icon: "fa-bicycle", color: "#55efc4" },
            { word: "Tree", thai: "ต้นไม้", icon: "fa-tree", color: "#27ae60" },
            { word: "Ghost", thai: "ผี", icon: "fa-ghost", color: "#636e72" },
            { word: "Burger", thai: "เบอร์เกอร์", icon: "fa-burger", color: "#e67e22" },
            { word: "Pizza", thai: "พิซซ่า", icon: "fa-pizza-slice", color: "#e74c3c" },
            { word: "Apple", thai: "แอปเปิ้ล", icon: "fa-apple-whole", color: "#e74c3c" },
            { word: "Camera", thai: "กล้อง", icon: "fa-camera", color: "#6c5ce7" },
            { word: "Robot", thai: "หุ่นยนต์", icon: "fa-robot", color: "#95a5a6" },
            { word: "Sun", thai: "พระอาทิตย์", icon: "fa-sun", color: "#f39c12" },
            { word: "Moon", thai: "พระจันทร์", icon: "fa-moon", color: "#f1c40f" },
            { word: "Heart", thai: "หัวใจ", icon: "fa-heart", color: "#d63031" },
            { word: "Umbrella", thai: "ร่ม", icon: "fa-umbrella", color: "#9b59b6" },
            { word: "Key", thai: "กุญแจ", icon: "fa-key", color: "#f39c12" }
        ];

        // --- 2. Core Variables ---
        let gameWords = [];
        let currentStage = 0;
        let gridSize = 3;
        let emptyPos = { r: 0, c: 0 };
        let isSolving = false; // Prevents interaction during shuffle/solve
        let moves = 0;
        let seconds = 0;
        let timerInterval = null;
        let currentWordData = {};
        
        // ** Stack for Smart Solving **
        let moveHistory = []; 

        // ** SECRET AUTO BOT VARIABLES **
        let isAutoPlaying = false; // Bot Status

        // DOM Elements
        const board = document.getElementById('board');
        const overlay = document.getElementById('overlay');
        const previewIcon = document.getElementById('previewIcon');
        const timeEl = document.getElementById('timer');
        const movesEl = document.getElementById('moveCount');
        const titleEl = document.getElementById('appTitle');

        // --- 3. Secret Bot Toggle Logic ---
        let lastTap = 0;
        
        // Support both Double Click (PC) and Double Tap (Mobile)
        titleEl.addEventListener('click', handleTitleTap);
        titleEl.addEventListener('touchend', (e) => {
            // e.preventDefault(); // Optional: prevent zoom
            handleTitleTap(e);
        });

        function handleTitleTap(e) {
            const currentTime = new Date().getTime();
            const tapLength = currentTime - lastTap;
            
            // Detect Double Tap (< 500ms)
            if (tapLength < 500 && tapLength > 0) {
                toggleSecretBot();
            }
            lastTap = currentTime;
        }

        function toggleSecretBot() {
            isAutoPlaying = !isAutoPlaying;
            
            if (isAutoPlaying) {
                // Activate
                titleEl.classList.add('active-bot');
                document.getElementById('botStatus').style.display = 'block';
                
                // If we are already in game and idle, start solving
                if (document.getElementById('screen-game').classList.contains('active') && !isSolving) {
                    triggerSmartSolve();
                }
            } else {
                // Deactivate
                titleEl.classList.remove('active-bot');
                document.getElementById('botStatus').style.display = 'none';
            }
        }

        // --- 4. Navigation ---
        function switchScreen(screenName) {
            document.querySelectorAll('.screen').forEach(s => s.classList.remove('active'));
            document.getElementById(`screen-${screenName}`).classList.add('active');
        }

        function goHome() {
            stopTimer();
            switchScreen('menu');
        }

        function initGameSession(size) {
            gridSize = size;
            document.documentElement.style.setProperty('--tile-count', gridSize);
            document.getElementById('modeName').innerText = (size === 3) ? "3x3 Mode" : "4x4 Mode";

            gameWords = [...fullDatabase];
            shuffleArray(gameWords); 

            currentStage = 0;
            switchScreen('game');
            loadLevel();
        }

        function shuffleArray(array) {
            for (let i = array.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [array[i], array[j]] = [array[j], array[i]];
            }
        }

        // --- 5. Level Loading & Logic ---
        function loadLevel() {
            stopTimer();
            isSolving = true; 

            currentWordData = gameWords[currentStage % gameWords.length];
            document.getElementById('displayStage').innerText = currentStage + 1;
            document.documentElement.style.setProperty('--primary', currentWordData.color);
            previewIcon.className = `fa-solid ${currentWordData.icon}`;
            
            moves = 0;
            seconds = 0;
            updateStatsUI();

            createBoard(currentWordData.icon); 
            moveHistory = []; // Reset history for new level

            // Start Sequence: Preview -> Shuffle -> Play/Auto
            setTimeout(async () => {
                let shuffleSteps = gridSize === 3 ? 30 : 60;
                await performSmartShuffle(shuffleSteps);
                
                startTimer();
                isSolving = false; 

                // *** AUTO BOT TRIGGER ***
                if (isAutoPlaying) {
                    // Wait a moment then start solving
                    setTimeout(triggerSmartSolve, 1000);
                }
            }, 1000); // 1s Preview
        }

        function resetLevel() {
            if(isSolving) return;
            loadLevel(); 
        }

        function createBoard(iconClass) {
            board.innerHTML = '';
            let tileCount = gridSize * gridSize;
            
            for(let i=0; i<tileCount; i++) {
                let r = Math.floor(i / gridSize);
                let c = i % gridSize;
                
                if (i === tileCount - 1) {
                    let div = document.createElement('div');
                    div.className = 'tile empty';
                    div.dataset.r = r;
                    div.dataset.c = c;
                    board.appendChild(div);
                    emptyPos = { r, c };
                } else {
                    let div = createTile(r, c, iconClass, i);
                    board.appendChild(div);
                }
            }
        }

        function createTile(row, col, iconClass, originalIndex) {
            let div = document.createElement('div');
            div.className = 'tile';
            div.dataset.r = row;
            div.dataset.c = col;
            div.dataset.original = originalIndex;
            div.onclick = () => { if(!isSolving) handleUserClick(div); };

            let content = document.createElement('div');
            content.className = 'tile-content';
            content.innerHTML = `<i class="fa-solid ${iconClass}"></i>`;
            
            let originalR = Math.floor(originalIndex / gridSize);
            let originalC = originalIndex % gridSize;
            let moveY = originalR * -100; 
            let moveX = originalC * -100;

            content.style.width = `${gridSize * 100}%`;
            content.style.height = `${gridSize * 100}%`;
            content.style.top = `${moveY}%`;
            content.style.left = `${moveX}%`;

            div.appendChild(content);
            return div;
        }

        // --- 6. Shuffle Logic (Generates Solvable Puzzle) ---
        async function performSmartShuffle(steps) {
            let lastMovedTile = null;

            for(let i=0; i<steps; i++) {
                let neighbors = getMovableNeighbors();
                let validNeighbors = neighbors.filter(n => n !== lastMovedTile);
                if(validNeighbors.length === 0) validNeighbors = neighbors;

                let randomTile = validNeighbors[Math.floor(Math.random() * validNeighbors.length)];
                
                swapTileLogic(randomTile); // Record this move to stack
                lastMovedTile = randomTile;
                
                // Fast shuffle visual
                await new Promise(r => setTimeout(r, 20)); 
            }
        }

        function getMovableNeighbors() {
            let neighbors = [];
            let { r, c } = emptyPos;
            const candidates = [{ r: r-1, c: c }, { r: r+1, c: c }, { r: r, c: c-1 }, { r: r, c: c+1 }];
            candidates.forEach(pos => {
                if(pos.r >= 0 && pos.r < gridSize && pos.c >= 0 && pos.c < gridSize) {
                    let tile = document.querySelector(`.tile[data-r='${pos.r}'][data-c='${pos.c}']`);
                    if(tile) neighbors.push(tile);
                }
            });
            return neighbors;
        }

        // --- 7. Movement & History Logic ---
        function handleUserClick(tile) {
            let r = parseInt(tile.dataset.r);
            let c = parseInt(tile.dataset.c);
            let dr = Math.abs(r - emptyPos.r);
            let dc = Math.abs(c - emptyPos.c);

            if (dr + dc === 1) {
                swapTileLogic(tile); 
                moves++;
                updateStatsUI();
                checkWin();
            }
        }

        function swapTileLogic(clickedDiv) {
            let emptyDiv = document.querySelector(`.tile.empty`);
            
            // Push to stack for Backtracking/Solving
            moveHistory.push(clickedDiv);

            swapNodes(clickedDiv, emptyDiv);

            let clickedR = parseInt(clickedDiv.dataset.r);
            let clickedC = parseInt(clickedDiv.dataset.c);
            let emptyR = parseInt(emptyDiv.dataset.r);
            let emptyC = parseInt(emptyDiv.dataset.c);

            clickedDiv.dataset.r = emptyR;
            clickedDiv.dataset.c = emptyC;
            emptyDiv.dataset.r = clickedR;
            emptyDiv.dataset.c = clickedC;

            emptyPos = { r: clickedR, c: clickedC };
        }

        function swapNodes(n1, n2) {
            let p1 = n1.parentNode;
            let s1 = n1.nextSibling;
            let p2 = n2.parentNode;
            let s2 = n2.nextSibling;
            if (s1 === n2) p1.insertBefore(n2, n1);
            else if (s2 === n1) p1.insertBefore(n1, n2);
            else {
                p1.insertBefore(n2, s1);
                p2.insertBefore(n1, s2);
            }
        }

        // --- 8. Auto Play (Bot) Logic ---
        
        function triggerSmartSolve() {
            smartSolve();
        }

        async function smartSolve() {
            if(isSolving) return;
            isSolving = true;
            stopTimer();

            // Reverse Walk logic
            while(moveHistory.length > 0) {
                let tileToUndo = moveHistory.pop(); // Get last moved tile
                
                // Verify proximity (safety check)
                let r = parseInt(tileToUndo.dataset.r);
                let c = parseInt(tileToUndo.dataset.c);
                let dr = Math.abs(r - emptyPos.r);
                let dc = Math.abs(c - emptyPos.c);

                if(dr + dc === 1) {
                    // Visual Swap
                    let emptyDiv = document.querySelector(`.tile.empty`);
                    swapNodes(tileToUndo, emptyDiv);

                    // Update Data
                    let tempR = tileToUndo.dataset.r;
                    let tempC = tileToUndo.dataset.c;
                    tileToUndo.dataset.r = emptyDiv.dataset.r;
                    tileToUndo.dataset.c = emptyDiv.dataset.c;
                    emptyDiv.dataset.r = tempR;
                    emptyDiv.dataset.c = tempC;
                    
                    emptyPos = { r: parseInt(tempR), c: parseInt(tempC) };

                    // Update UI (Fake user stats)
                    if (isAutoPlaying) {
                        moves++;
                        updateStatsUI();
                    }

                    // ** Human-like Delay **
                    // Random delay between 300ms to 600ms
                    let delay = Math.floor(Math.random() * 300) + 300;
                    await new Promise(r => setTimeout(r, delay));
                }
            }

            // Finish
            setTimeout(() => {
                showWin(isAutoPlaying); // If auto playing, treat as bot win
                isSolving = false;
            }, 500);
        }

        // --- 9. Win & Loop Logic ---
        function checkWin() {
            let tilesDOM = document.querySelectorAll('.tile:not(.empty)');
            let correctCount = 0;
            tilesDOM.forEach(tile => {
                let currentPos = parseInt(tile.dataset.r) * gridSize + parseInt(tile.dataset.c);
                let originalPos = parseInt(tile.dataset.original);
                if(currentPos === originalPos) correctCount++;
            });

            if (correctCount === (gridSize*gridSize - 1)) {
                stopTimer();
                isSolving = true;
                setTimeout(() => showWin(false), 500);
            }
        }

        function showWin(isBotWin) {
            document.getElementById('resultWord').innerText = currentWordData.word.toUpperCase();
            document.getElementById('resultThai').innerText = currentWordData.thai;
            document.getElementById('resultIcon').className = `fa-solid ${currentWordData.icon}`;
            document.documentElement.style.setProperty('--primary', currentWordData.color);

            let m = Math.floor(seconds / 60);
            let s = seconds % 60;
            document.getElementById('resTime').innerText = `${m.toString().padStart(2,'0')}:${s.toString().padStart(2,'0')}`;
            document.getElementById('resMoves').innerText = moves;

            if(!isBotWin) speakWord();
            
            overlay.classList.add('show');

            // *** AUTO BOT LOOP ***
            if (isAutoPlaying) {
                // Read word (optional for bot)
                speakWord();
                // Wait 4 seconds then go next
                setTimeout(() => {
                    // Check if bot was turned off during wait
                    if(isAutoPlaying) nextLevel();
                }, 4000);
            }
        }

        function speakWord() {
            let utterance = new SpeechSynthesisUtterance(currentWordData.word);
            utterance.lang = 'en-US';
            speechSynthesis.speak(utterance);
        }

        function nextLevel() {
            overlay.classList.remove('show');
            currentStage++;
            loadLevel();
        }

        // --- Standard UI ---
        function startTimer() {
            stopTimer();
            timerInterval = setInterval(() => {
                seconds++;
                updateStatsUI();
            }, 1000);
        }

        function stopTimer() {
            if(timerInterval) clearInterval(timerInterval);
        }

        function updateStatsUI() {
            let m = Math.floor(seconds / 60);
            let s = seconds % 60;
            timeEl.innerText = `${m.toString().padStart(2,'0')}:${s.toString().padStart(2,'0')}`;
            movesEl.innerText = moves;
        }

    </script>
</body>
</html>
